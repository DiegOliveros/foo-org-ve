#include <iostream>
#include <cstdlib>
#include <cmath>
#include <GL/glut.h>
#include <GL/gl.h>

using namespace std;

int wXYView;
int wXZView;
int wYZView;
int wMMView;

//GLdouble ang = 0;
//GLdouble dst = 5;

GLdouble angTOP = 0;
GLdouble angRGH = 0;
GLdouble dist = 4;

int prevX;
int prevY;

//GLdouble angX;
//GLdouble angY;

// --------------------------------------------------------------------------------

GLdouble vAX = /* */0;
GLdouble vAY = /* */1;
GLdouble vAZ = /* */0;

GLdouble vBX = /* */1;
GLdouble vBY = /* */0;
GLdouble vBZ = /* */0;

GLdouble vCX = /* */0;
GLdouble vCY = /* */0;
GLdouble vCZ = /**/-1;

void calcCrossProduct(GLdouble v1[3], GLdouble v2[3], GLdouble vr[3]) {
#define CX 0
#define CY 1
#define CZ 2

	vr[CX] = /* */(v1[CY] * v2[CZ] - v1[CZ] * v2[CY]);
	vr[CY] = /**/-(v1[CX] * v2[CZ] - v1[CZ] * v2[CX]);
	vr[CZ] = /* */(v1[CX] * v2[CY] - v1[CY] * v2[CX]);

	double mod = sqrt( //
			/*    */vr[CX] * vr[CX] + //
					vr[CY] * vr[CY] + //
					vr[CZ] * vr[CZ]);

	vr[CX] /= mod;
	vr[CY] /= mod;
	vr[CZ] /= mod;

#undef CX
#undef CY
#undef CZ
}

// --------------------------------------------------------------------------------

void updateRef() {
	glPushMatrix();

	cout << "***************************************" << endl;
	glLoadIdentity();
	cout << "angTOP: " << angTOP << endl;
	glRotated(angTOP, vAX, vAY, vAZ);
	cout << "*vAX: " << vAX << "; vAY: " << vAY << "; vAZ: " << vAZ << endl;
	cout << "*vBX: " << vBX << "; vBY: " << vBY << "; vBZ: " << vBZ << endl;

	GLdouble d1[16] = //
			/*  */{ vBX, vBY, vBZ, 0, //
					0, 0, 0, 0, //
					0, 0, 0, 0, //
					0, 0, 0, 1 };

	glMultMatrixd(d1);
	glGetDoublev(GL_MODELVIEW_MATRIX, d1);

	//	for (int i = 0; i < 16; i++) {
	//		cout << i << ";" << d1[i] << endl;
	//	}

	vBX = d1[0];
	vBY = d1[1];
	vBZ = d1[2];

	glLoadIdentity();
	cout << "angRGH: " << angRGH << endl;
	glRotated(angRGH, vBX, vBY, vBZ);

	GLdouble d2[16] = //
			/*  */{ vAX, vAY, vAZ, 0, //
					0, 0, 0, 0, //
					0, 0, 0, 0, //
					0, 0, 0, 1 };

	glMultMatrixd(d2);
	glGetDoublev(GL_MODELVIEW_MATRIX, d2);
	vAX = d2[0];
	vAY = d2[1];
	vAZ = d2[2];

	//	GLdouble v1[3] = { vAX, vAY, vAZ };
	//	GLdouble v2[3] = { vAX, vAY, vAZ };
	//	GLdouble v2[3] = { vAX, vAY, vAZ };

	GLdouble v1[3] = { vAX, vAY, vAZ };
	GLdouble v2[3] = { vBX, vBY, vBZ };
	GLdouble vr[3] = { 0, 0, 0 };

	calcCrossProduct(v1, v2, vr);
	vCX = vr[0];
	vCY = vr[1];
	vCZ = vr[2];

	cout << "vAX: " << vAX << "; vAY: " << vAY << "; vAZ: " << vAZ << endl;
	cout << "vBX: " << vBX << "; vBY: " << vBY << "; vBZ: " << vBZ << endl;
	cout << "vCX: " << vCX << "; vCY: " << vCY << "; vCZ: " << vCZ << endl;

	glPopMatrix();
}

void updateCameraPos() {
	updateRef();

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(60, 1, 1, 10);

	// vC por naturaleza inicialmente mira hacia adentro (negativo)
	// y el ojo lo quiero poner hacia afuera (positivo)
	gluLookAt( //
			-dist* vCX , -dist* vCY , -dist* vCZ , //  eye
			0, 0, 0, //  cnt
			vAX, vAY, vAZ); // upv
	glMatrixMode(GL_MODELVIEW);
}

// --------------------------------------------------------------------------------


// --------------------------------------------------------------------------------

void reshape(int width, int height) {
	glViewport(0, 0, width, height);
	updateCameraPos();
}

// --------------------------------------------------------------------------------


void drawBox4d(GLdouble cx, GLdouble cy, GLdouble cz, GLdouble l) {
	glBegin(GL_QUADS);

	GLdouble xM = cx - l / 2;
	GLdouble xP = cx + l / 2;

	GLdouble yM = cy - l / 2;
	GLdouble yP = cy + l / 2;

	GLdouble zM = cz - l / 2;
	GLdouble zP = cz + l / 2;

	// ----------------------------------------
	// yM (BOT)
	// ----------------------------------------
	glColor3f(0, 1, 0);
	glVertex3f(xM, yM, zM);
	glVertex3f(xP, yM, zM);
	glVertex3f(xP, yM, zP);
	glVertex3f(xM, yM, zP);

	// ----------------------------------------
	// zP (FRN)
	// ----------------------------------------
	glColor3f(0, 0, 1);
	glVertex3f(xP, yM, zP);
	glVertex3f(xM, yM, zP);
	glVertex3f(xM, yP, zP);
	glVertex3f(xP, yP, zP);

	// ----------------------------------------
	// yP (TOP)
	// ----------------------------------------
	glColor3f(1, 1, 0);
	glVertex3f(xP, yP, zP);
	glVertex3f(xM, yP, zP);
	glVertex3f(xM, yP, zM);
	glVertex3f(xP, yP, zM);

	// ----------------------------------------
	// zM (BCK)
	// ----------------------------------------
	glColor3f(1, 1, 1);
	glVertex3f(xP, yP, zM);
	glVertex3f(xM, yP, zM);
	glVertex3f(xM, yM, zM);
	glVertex3f(xP, yM, zM);

	// ----------------------------------------
	// xM (LFT)
	// ----------------------------------------
	glColor3f(1, 0, 0);
	glVertex3f(xM, yP, zP);
	glVertex3f(xM, yM, zP);
	glVertex3f(xM, yM, zM);
	glVertex3f(xM, yP, zM);

	// ----------------------------------------
	// xP (RGH)
	// ----------------------------------------
	glColor3f(1, 0.5, 0);
	glVertex3f(xP, yP, zP);
	glVertex3f(xP, yM, zP);
	glVertex3f(xP, yM, zM);
	glVertex3f(xP, yP, zM);

	glEnd();
}

void drawAxes4(GLdouble cx, GLdouble cy, GLdouble cz, GLdouble l) {

	glColor3f(1, 1, 1);

	glBegin(GL_LINES);

	glVertex3d(0, 0, 0);
	glVertex3d(3* vAX , 3* vAY , 3* vAZ );

	//	glVertex3d(0, 0, 0);
	//	glVertex3d(3* vBX , 3* vBY , 3* vBZ );

	glVertex3d(0, 0, 0);
	glVertex3d(-3* vCX , -3* vCY , -3* vCZ );

	glColor3f(1, 0.5, 0); // X->R
	glVertex3d(0, 0, 0);
	glVertex3d(3, 0, 0);

	glColor3f(1, 1, 0); // Y->G
	glVertex3d(0, 0, 0);
	glVertex3d(0, 3, 0);

	glColor3f(0, 0, 1); // Z->B
	glVertex3d(0, 0, 0);
	glVertex3d(0, 0, 3);

	glEnd();
}

// --------------------------------------------------------------------------------

void display() {
	// glClear(GL_COLOR_BUFFER_BIT);
	glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
	glLoadIdentity();
	drawBox4d(0, 0, 0, 2);
	drawAxes4(0, 0, 0, 10);
	glFlush();
}

// --------------------------------------------------------------------------------

void init() {
	glClearColor(0, 0, 0, 0);
	glDisable(GL_CULL_FACE);
	glEnable(GL_DEPTH_TEST);
	updateRef();
}

// --------------------------------------------------------------------------------

int mouse_a;

void mouseFunc(int a, int b, int x, int y) {
	cout << "a: " << a << "; b: " << b //
			<< "; x: " << x << "; y: " << y //
			<< endl;

	angTOP = 0;
	angRGH = 0;
	mouse_a = a;
	prevX = x;
	prevY = y;
}

// --------------------------------------------------------------------------------

void motionFunc(int x, int y) {
	double dx = x - prevX;
	double dy = y - prevY;

	//dx /= 10;
	//dy /= 10;

	if (mouse_a == 0) {
		angTOP = dx;
	}

	if (mouse_a == 2) {
		angRGH = dy;
	}

	if (mouse_a == 1) {
		dist += dy / 10;
	}

	cout << "x: " << x << "; y: " << y //
			<< "; dx: " << dx << "; dy: " << dy //
			<< endl;

	updateCameraPos();

	glutSetWindow(wXYView);
	glutPostRedisplay();

	glutSetWindow(wXZView);
	glutPostRedisplay();

	glutSetWindow(wYZView);
	glutPostRedisplay();

	glutSetWindow(wMMView);
	glutPostRedisplay();

	prevX = x;
	prevY = y;
}

// --------------------------------------------------------------------------------

void initXYView() {
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowPosition(640, 0);
	glutInitWindowSize(640, 350);
	wXYView = glutCreateWindow("XYView");
	glutDisplayFunc(display);

	glClearColor(0, 0, 0, 0);
	glDisable(GL_CULL_FACE);
	glEnable(GL_DEPTH_TEST);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(60, 1, 1, 10);

	gluLookAt( //
			0, 0, 4, //  eye
			0, 0, 0, //  cnt
			0, 1, 0); // upv
	glMatrixMode(GL_MODELVIEW);
}

void initXZView() {
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowPosition(0, 400);
	glutInitWindowSize(640, 350);
	wXZView = glutCreateWindow("XZView");
	glutDisplayFunc(display);

	glClearColor(0, 0, 0, 0);
	glDisable(GL_CULL_FACE);
	glEnable(GL_DEPTH_TEST);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(60, 1, 1, 10);

	gluLookAt( //
			0, 4, 0, //  eye
			0, 0, 0, //  cnt
			0, 0, -1); // upv
	glMatrixMode(GL_MODELVIEW);
}

void initYZView() {
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowPosition(640, 400);
	glutInitWindowSize(640, 350);
	wYZView = glutCreateWindow("YZView");
	glutDisplayFunc(display);

	glClearColor(0, 0, 0, 0);
	glDisable(GL_CULL_FACE);
	glEnable(GL_DEPTH_TEST);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(60, 1, 1, 10);

	gluLookAt( //
			4, 0, 0, //  eye
			0, 0, 0, //  cnt
			0, 1, 0); // upv
	glMatrixMode(GL_MODELVIEW);
}

int main(int argc, char **argv) {
	glutInit(&argc, argv);

//	initXYView();
//	initXZView();
//	initYZView();

	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowPosition(0, 0);
	glutInitWindowSize(640, 350);

	wMMView = glutCreateWindow(argv[0]);

	init();

	glutMouseFunc/* */(mouseFunc);
	glutMotionFunc/**/(motionFunc);

	glutDisplayFunc(display);
	glutReshapeFunc(reshape);

	glutMainLoop();
}
