#include <iostream>
#include <cstdlib>
#include <cmath>
#include <GL/glut.h>
#include <GL/gl.h>

using namespace std;

GLdouble ang = 0;
GLdouble dst = 5;

GLdouble angZZ = 0;
GLdouble angXX = 0;

int prevX;
int prevY;

GLdouble angX;
GLdouble angY;

// --------------------------------------------------------------------------------

GLdouble vAX = /* */0;
GLdouble vAY = /* */1;
GLdouble vAZ = /* */0;

GLdouble vBX = /* */1;
GLdouble vBY = /* */0;
GLdouble vBZ = /* */0;

GLdouble vCX = /* */0;
GLdouble vCY = /* */0;
GLdouble vCZ = /**/-1;

// --------------------------------------------------------------------------------

void updateCameraPos() {

	double y = 4 * sin(angXX);
	double r = 4 * cos(angXX);

	double z = r * sin(angZZ);
	double x = r * cos(angZZ);

	cout << "x: " << x << "; z: " << z //
			<< "; angZZ: " << angZZ << endl;

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(60, 1, 1, 10);
	gluLookAt( //
			x, y, z, //  eye
			0, 0, 0, //  cnt
			0, 1, 0); // upv
	glMatrixMode(GL_MODELVIEW);
}

// --------------------------------------------------------------------------------

void calcCrossProduct(GLdouble v1[3], GLdouble v2[3], GLdouble vr[3]) {
#define CX 0
#define CY 1
#define CZ 2

	vr[CX] = (v1[CY] * v2[CZ] - v1[CZ] * v2[CY]);
	vr[CY] = (v1[CX] * v2[CZ] - v1[CZ] * v2[CX]);
	vr[CZ] = (v1[CX] * v2[CY] - v1[CY] * v2[CX]);

	double mod = sqrt( //
			/*    */vr[CX] * vr[CX] + //
					vr[CY] * vr[CY] + //
					vr[CZ] * vr[CZ]);

	vr[CX] /= mod;
	vr[CY] /= mod;
	vr[CZ] /= mod;

#undef CX
#undef CY
#undef CZ
}

// --------------------------------------------------------------------------------

void reshape(int width, int height) {
	glViewport(0, 0, width, height);

	updateCameraPos();
}

// --------------------------------------------------------------------------------


void drawBox4d(GLdouble cx, GLdouble cy, GLdouble cz, GLdouble l) {
	glBegin(GL_QUADS);

	GLdouble xM = cx - l / 2;
	GLdouble xP = cx + l / 2;

	GLdouble yM = cy - l / 2;
	GLdouble yP = cy + l / 2;

	GLdouble zM = cz - l / 2;
	GLdouble zP = cz + l / 2;

	// ----------------------------------------
	// yM (BOT)
	// ----------------------------------------
	glColor3f(1, 0, 0);
	glVertex3f(xM, yM, zM);
	glVertex3f(xP, yM, zM);
	glVertex3f(xP, yM, zP);
	glVertex3f(xM, yM, zP);

	// ----------------------------------------
	// zP (FRN)
	// ----------------------------------------
	glColor3f(0, 1, 0);
	glVertex3f(xP, yM, zP);
	glVertex3f(xM, yM, zP);
	glVertex3f(xM, yP, zP);
	glVertex3f(xP, yP, zP);

	// ----------------------------------------
	// yP (TOP)
	// ----------------------------------------
	glColor3f(0, 0, 1);
	glVertex3f(xP, yP, zP);
	glVertex3f(xM, yP, zP);
	glVertex3f(xM, yP, zM);
	glVertex3f(xP, yP, zM);

	// ----------------------------------------
	// zM (BCK)
	// ----------------------------------------
	glColor3f(1, 1, 0);
	glVertex3f(xP, yP, zM);
	glVertex3f(xM, yP, zM);
	glVertex3f(xM, yM, zM);
	glVertex3f(xP, yM, zM);

	// ----------------------------------------
	// xM (LFT)
	// ----------------------------------------
	glColor3f(1, 0, 1);
	glVertex3f(xM, yP, zP);
	glVertex3f(xM, yM, zP);
	glVertex3f(xM, yM, zM);
	glVertex3f(xM, yP, zM);

	// ----------------------------------------
	// xP (RGH)
	// ----------------------------------------
	glColor3f(0, 1, 1);
	glVertex3f(xP, yP, zP);
	glVertex3f(xP, yM, zP);
	glVertex3f(xP, yM, zM);
	glVertex3f(xP, yP, zM);

	glEnd();
}

void updateRef() {
	glPushMatrix();

	cout << "***************************************" << endl;
	glLoadIdentity();
	glRotated(10, vAX, vAY, vAZ);
	cout << "*vAX: " << vAX << "; vAY: " << vAY << "; vAZ: " << vAZ << endl;
	cout << "*vBX: " << vBX << "; vBY: " << vBY << "; vBZ: " << vBZ << endl;

	GLdouble d1[16] = //
			/*  */{ vBX, vBY, vBZ, 0, //
					0, 0, 0, 0, //
					0, 0, 0, 0, //
					0, 0, 0, 1 };

	glMultMatrixd(d1);
	glGetDoublev(GL_MODELVIEW_MATRIX, d1);

	//	for (int i = 0; i < 16; i++) {
	//		cout << i << ";" << d1[i] << endl;
	//	}

	vBX = d1[0];
	vBY = d1[1];
	vBZ = d1[2];

	glLoadIdentity();
	glRotated(10, vBX, vBY, vBZ);

	GLdouble d2[16] = //
			/*  */{ vAX, vAY, vAZ, 0, //
					0, 0, 0, 0, //
					0, 0, 0, 0, //
					0, 0, 0, 1 };

	glMultMatrixd(d2);
	glGetDoublev(GL_MODELVIEW_MATRIX, d2);
	vAX = d2[0];
	vAY = d2[1];
	vAZ = d2[2];

	//	GLdouble v1[3] = { vAX, vAY, vAZ };
	//	GLdouble v2[3] = { vAX, vAY, vAZ };
	//	GLdouble v2[3] = { vAX, vAY, vAZ };

	GLdouble v1[3] = { vAX, vAY, vAZ };
	GLdouble v2[3] = { vBX, vBY, vBZ };
	GLdouble vr[3] = { 0, 0, 0 };

	calcCrossProduct(v1, v2, vr);
	vCX = vr[0];
	vCY = vr[1];
	vCZ = vr[2];

	cout << "vAX: " << vAX << "; vAY: " << vAY << "; vAZ: " << vAZ << endl;
	cout << "vBX: " << vBX << "; vBY: " << vBY << "; vBZ: " << vBZ << endl;
	cout << "vCX: " << vCX << "; vCY: " << vCY << "; vCZ: " << vCZ << endl;

	glPopMatrix();
}

void drawAxes4(GLdouble cx, GLdouble cy, GLdouble cz, GLdouble l) {

	glColor3f(1, 1, 1);

	glBegin(GL_LINES);

	glVertex3d(0, 0, 0);
	glVertex3d(vAX, vAY, vAZ);

	glVertex3d(0, 0, 0);
	glVertex3d(vBX, vBY, vBZ);

	glVertex3d(0, 0, 0);
	glVertex3d(vCX, vCY, vCZ);

	glColor3f(1, 0, 0); // X->R
	glVertex3d(0, 0, 0);
	glVertex3d(1, 0, 0);

	glColor3f(0, 1, 0); // Y->G
	glVertex3d(0, 0, 0);
	glVertex3d(0, 1, 0);

	glColor3f(0, 0, 1); // Z->B
	glVertex3d(0, 0, 0);
	glVertex3d(0, 0, 1);

	glEnd();
}

// --------------------------------------------------------------------------------

void display() {
	// glClear(GL_COLOR_BUFFER_BIT);
	glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
	glLoadIdentity();
	//	drawBox4d(0, 0, 0, 2);
	drawAxes4(0, 0, 0, 10);
	glFlush();
}

// --------------------------------------------------------------------------------

void init() {
	glClearColor(0, 0, 0, 0);
	glDisable(GL_CULL_FACE);
	glEnable(GL_DEPTH_TEST);
	updateRef();
}

// --------------------------------------------------------------------------------

void mouseFunc(int a, int b, int x, int y) {
	cout << "a: " << a << "; b: " << b //
			<< "; x: " << x << "; y: " << y //
			<< endl;

	prevX = x;
	prevY = y;
}

// --------------------------------------------------------------------------------

void motionFunc(int x, int y) {
	double dx = x - prevX;
	double dy = y - prevY;

	dx /= 10;
	dy /= 10;

	angZZ += dx;
	angXX += dy;

	cout << "x: " << x << "; y: " << y //
			<< "; dx: " << dx << "; dy: " << dy //
			<< endl;

	updateCameraPos();
	glutPostRedisplay();

	prevX = x;
	prevY = y;
}

// --------------------------------------------------------------------------------

int main(int argc, char **argv) {
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowPosition(50, 50);
	glutInitWindowSize(640, 480);
	glutCreateWindow(argv[0]);

	init();

	glutMouseFunc/* */(mouseFunc);
	glutMotionFunc/**/(motionFunc);

	glutDisplayFunc(display);
	glutReshapeFunc(reshape);
	glutMainLoop();
}
